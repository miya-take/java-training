### Stringインスタンスの不変性
- 不変 (immutable)
  - インスタンス化の後に内容が絶対に変化しないように設計されたクラスのこと
  - 参照やスレッドに関連したある種の複雑な不具合が、原理的に起こり得ないという特徴を保つため、プログラムのあらゆる箇所で利用されているStringにも採用されている
  - `+` に夜連結が行われた瞬間、古いインスタンスは捨てられ、連結後の情報を持つ新インスタンスが`new`により生成される
    - `+`演算子による文字列連結は内部で`new`を繰り替えること。newによるインスタンス生成は、計算などに比べて、JVMに大きな負荷がかかる
- 可変(mutable)
  - `StringBuffer` や `StringBuilder`は可変んあクラスとして設計されている
  - `append()`メソッドの呼び出しのたびにnewを行わない。バッファを拡大しつつあたらな文字列を追記していく


## 03_Collection
### データ構造(datastructure)
- データをどのようにまとめて扱うかを示したもの
- list
  - 配列のように、順序づけて格納するデータ構造nこと
### コレクションフレームワーク collectioin framework
- 様々なデータ構造に対応した、「データをまとめて格納するために入れ物クラス」がAPIとして準備されている。
- `java.util`パッケージに属し、collection-frameworkと総称されている
- 
- 単独の値を保存
  - `ArrayList``LinkedList`
    - 重複許可、順序保証(list)
  - `HashSet``LinkedHashSet``TreeSet`
    - 重複不可、順序非保証(Set)
    - 集合(set)というデータ構造を実現している
- ペアの値を保存(Map)
  - `HashMap``LinkedHashMap``TreeMap`

### コレクションクラスにはできないこと
- **インスタンスでないものは格納できない。基本データ型は格納ができない**
- プリミティブ型はラップすることで使用できるint->Integer
### リストの中身を一つずつ取り出す方法
- for
- 拡張for
- イテレータ
  - イテレータとは、箱を順番にやす矢印
  - `java.tuil.Iterator<~>`型のインスタントして扱う
    - `ArrayList<String>`の場合には、イテレータとして`Iterator<String>`を利用する
    - Iteratorを使用するサインは、`new`演算子は使用しない。リスト変数自体の`iterator()`メソッドを呼び出すことでリストの先頭をさしたイテレータのインスタンを得ることができる
  - イテレータのメソッドを呼び出すと、**そのリストよりも先頭（最初の箱よりももっと前）を指定した状態の矢印を取得している**
  - イテレータのインスタンスに対する操作
      - `hasNext()`
        - 次の要素をさせるか調査する
      - `next()`
        - 次の要素を指定し、その内容をさす
#### LinkedList
- ArrayListっと似たような動作をする
- ただしArrayListとは **クラスの内部実装に違いがある**
- LinkedListは**連結リスト**という構造を応用して作られteiru
- LinkedListが得意な操作(ArrayListが苦手な操作)
  - 要素の挿入・削除`add()``remove()`
- LinkedListが苦手な操作(ArrayListが得意な操作)
  - 指定位置の要素の取得`get()`

### コレクションのインスタンスは極力曖昧な型で取り扱うのが通なやり方
- ArrayListとLinkedListは共に、`java.util.List`インターフェースを実装している
```
java.util.List
　└ ArrayList
　└ LinkedList
```
- ざっくりListとして扱う方がメリットが大きい
  - **引数、戻り値、ローカル変数には、極力曖昧な型（インターフェイス型）を利用できないかを検討して、積極的に利用する**
- 例えば下のメソッドの役割は「リストの中身を取り出して一つずつ表示すること」
  - なのでリストの内部構造が配列であるか連結リストであるかあは関係ない。
```
public static void printList(List<String> list){
  for (String a : list){
    System.out.println(a);
  }
}
```
### Set集合
- 重複した値は無視される
- set()やget()がない。要素同士に順序がないため。添字は使えない
- 一つずつ取り出す際の順序は不明
#### Setの実装バリエーション
- LinkedHashSet
  - 値を格納した順序で整列j
- TreeSet
  - 自然順序付で整列
  - それぞれのクラスに固有の順序。Stringクラスでは辞書順になるように定義されている

### Map
- Mapは「ペアデータの集まり」であるため、Collectionインターフェイスとは継承関係にない
- 二つの情報を**key** と **value**のペアとして格納するデータ構造
- `java.util.Map`インターフェイスと`java.util.HashMap`クラスに代表される実装を用いることで、活用できる
- `Map<String, Integer>`String型のkeyと、Integer型の値value
- マップでは値の重複は許されるが、**key**の重複は許されない。同じkeyをput()すると値が上書きされる


### コレクションの応用
#### コレクションのネスト
- コレクションクラスは、要素として別のコレクションを格納することも可能
- Mapの中に、Listがネストした構造など
#### ネストで注意すること
- リストに格納されているのは、メモリのアドレス情報。
- なので、コレクションへ格納が終わった変数のインスタンスの中身を書き換えると、コレクションに格納済みの要素の中身も書き換わってしまう

# インスタンスの操作
- Javaにおける全てのクラスは、その継承関係を親へと辿ると、`java.lang.Object`クラスに行き着く
- Objectクラスが存在することのメリとお
  - 全クラスはObjectクラスで定義されたメソッドを持っていることが保証される
  - Object型変数には、あらゆるインスタンスを代入可能である
## 多くのインスタンスに共通して使える基本操作
- `toString()`
  - 文字列表現をえる
  - 関連するクラスObject
- `equals()`
  - 等価判定を行う
  - 関連するクラスObject
- `hashCode()`
  - ハッシュ値をえる
  - 関連するクラスObject
- `compareTo()`
  - 大小関係を判定する
  - 関連するクラスComparable
- `clone()`
  - 複製する
  - 関連するクラスObject, Cloneable
### toString()の操作
- 責務
  - インスタンスの内容を人が読んで理解できる文字列で表現したもの(文字列表現)として返すj
- インスタンスの中身を知り宝ったら、とにかく`toString()`を呼び出せば良い
- デバッグ作業やログ出力で役に立つ
- ただし、作成したインスタンスに、ただ`toString()`を実行しても、意味不明な出力しか返却されない
  - これは、親クラスである`Object`クラスの`toString()`メソッドを実行しているから
- **あるクラスがどのような文字列表現を返すべきかは、そのクラスを作った人にしかわからない**
- **なので、新しくクラスを作成したら、toString()をオーバーライドして、適切な文字列表現を返すように上書きする必要がある**

### 等価判定
#### 等価と等値の違い
- `equals()`メソッドは、2つの変数に入っているインスタンを比較して、等価(equivalent)であるかどうかを判定する
  - 等値(equality)とは全く別
  - equivalent(等価) equals
    - 指しているものが同じ内容であること
    - 同じアドレスでなくとも良い
    - すなわち下の場合 
    - `h1 != h2`だが`h1.equals(h2)`
```
Hero h1 = new Hero("AAA"); // 3345番地
Hero h2 = new Hero("AAA"); // 9191番地
```
  - equality(等値) ==
    - 指しているものが「完全に同一であること」
    - すなわち同じアドレスを指していること
    - 下の場合
    - `h1 == h2`
```
Hero h1 = new Hero("AAA"); // 3345番地
Hero h2 = h1;
```
- `==`演算子を用いる等値判定はJVMは簡単に行える。アドレスが同じかどうかを判定すれば良いだけだから
- 一方で、`equals()`を用いる等価判定は簡単でhないあ。
  - 二つのクラスが何を持って同一か、の基準はクラスによってまちまち
  - その判断はJVMではなく開発者が行う
  - Objectクラスに宣言済みの`equals()`メソッドの中身は、ただの等値判定ロジック

### equalsをオーバーライドした時の処理内容
- (1)自分自身が引数として渡された場合には無条件でtrue
- (2)nullが引数として渡された場合には、無条件でfalse
- (3)比較し型が異なるならば、falseを返す。（同じならば(4)に備えて、比較できるように適切にキャストする

### equalsは必ずオーバーライドすること
- クラスを作成したら必ずオーバーライドすること
- StringやInteger,DateのようなAPIクラスでは、equals()が適切にオーバーライドされているから、問題がなかった
- クラスを作成したら必ずしオーバーライドする
- オーバーライドが不要なクラス
  - そもそも等価を判定されうことが考えられないクラス（データではなく、主に処理ロジックを持っているクラス
  - 親クラスですでにオーバーライドされていて、そのロジックで問題のないクラス
### equalsをオーバーライドしても誤動作が起きることもHash系
- HashSetの内部動作
  - ArrayListのremove()は、equals()メソッドで要素を確認する
  - 一方でHashSetのremoveはそのような動作をしない。
    - 内部でnull判定やキャスト、各フィールドの等価判定を繰り返すような`equals()`メソッドをなんども呼び出していたら、**削除したい要素を探し出すために長い時間がかかり非効率だから**
- HashSetやHashMapのようなHash系のコレクションのクラスでの要素の探し方
  - 2段階で行われる
    1. 高速だが、あいまいな方法で、各要素に「だいたい同じか？」を問い合わせる
    2. 「だいたい同じ」要素にだけ、`equals()`で「厳密に同じか？」を問い合わせる
  - HashSetはだいたい同じかどうかを判定するために、**Hash値** を利用する(Hash code)
    - そのインスタンスの内容を数値として要約したもの
    - ハッシュ値の条件
      - 同じ等価なインスタンスからは、必ず同じハッシュ値が得られること
      - 異なるインスタンスからは、なるべく異なるハッシュ値が得られること
    - Javaでは「全てのオブジェクトは地震のハッシュ値を計算できるべきだある」という考えのもの、その責務をおった`hashCode()`メソッドがObjectクラスに定義されている。
      - すべてのインスタンスには`hashCode()`を呼び出された際に、ハッシュ条件に乗っ取った値を返す義務がある 
      - そのため、**hashCode()メソッドもクラスの開発者が正しくオーバーライドする必要がある**
```
class Hero
  String name;
  int hp;
  public int hashCode(){
    int result = 37;  // 適当な初期値を設定する
    result = result * 31 + name.hashCode(); // 各フィールドの値の影響を加える
    result = resutl * 31 : hp;   // 各フィールドの値の影響を加える
    return result; // 結果を返す
  }
```

### インスタ順序づけ
- `list.sort()`メソッドでもエラーは出現する。
  - 例えば、「口座を並び替える」と言っても、色々な並び替えの順序がある
- ただしあらかじめ、一般的に想定される並べ順を宣言sh知恵おけば良い。
  - 自然順序づけ
  - 自然順序づけが定めてあるクラスであれば、単なる`list.sort()`でもエラーば出ない
### Comparableインターフェイスの実装
- 自然順序を宣言するためには`java.lang.Comparable`インターフェイスを実装する
-  このインターフェースを実装すると、`compataTo()`メソッドのオーバーライドが強制されることになる

```
public class Account implements Comparable<Account> {
  int accountNumber;

  public int comparaTo(Account ob){
    if(this.number < obj.number) {
      return -1;
    }
    if(this.number > obj.number){
      return 1;
    }
    return 0;
  }
} 
```

- ※`TreeSet`クラスは内部で常に並び替えを行いながら要素を格納する
  - 基本的に`Comparable`を実装したクラスを要素として格納することを前提としたコレクションクラス
  - `Comparable`が実装されているか注意が必要
## インスタンスの複製
- インスタンスは代入してもコピーされない
- 参照情報がコピーされるだけであって、インスタンスの実体は一つのまま

```
Hero h1 =new Hero();
Hero h2 = h1;
```

- インスタンス自体を複製するためには、`clone()`メソッドを利用する

```
Hero h1 =new Hero("Yusha");
Hero h2 = h1.clone();
```
### cloneによる複製をサポートする
- `clone()`による複製をサポートするには、以下の作業が必要
1. Cloneableインターフェイスの実装
  - `java.lang.Cloneable`インターフェイスを実装して、外部に対して複製をサポートしていることをアピール
2. cloneメソッドをpublicでオーバーライドする
  - 新しいインスタンをnewで生成し、自身の全フィールドをコピーしてreturnで返す、という処理内容になる 
    - clone()をサポートした親クラスがある場合は、newではなく親の`super.clone()`を呼びインスタンを生成する
    - Java5以降では戻り値の方は自身のクラス名にする
    - Objectクラスで定義しているclone()メソッドはprotectedで宣言してあるために、外部からは呼び出せないからpublicでオーバライドする

- `Cloneable`は「clone()を実装することによって複製していることを表明する」だけに存在している
- こうした目的でも用いられるインターフェイスを、**マーカーインターフェイス**と呼ぶ。
  - 他には`java.io.Serializable`など

# 5様々なクラス
## 型安全
- Javaでは変数を用いるときに必ず型(type)を指定する
- 変数には、その下板ひ型の情報しか格納することはできない。**型には、格納するデータに制約をかける仕組み** 
- **変数に予期しない種類の情報が入ってしまうことを未然い防ぐための安全装置に役割**
- そのため、**変数には可能な限り厳密な型を指定する**。意図しない不正な値が入る余地を小さくできうrから
### 静的型付けと動的型付け
- 静的型付け（static typing）
  - Javaのようにコンパイル時に型を決定し、型安全を積極活用shテイク言語が採用している方針
- 動的型付け(Dynamic typing)
  - 変数などに型の指定をせず、コンパイルじに型チェックを行わない考え方
  - スクリプト言語などで採用されている
## ジェネリクス
- ジェネリクスを使って宣言されたクラスは、`< ~ >`記法を利用できる
  - ジェネリクスという用語に変えて、総称型やテンプレートという言葉が使われることもある
  - APIリファレンスにおいてもジェネリクス記法が利用的るかどうか判断できる
  - コレクションクラスには用いられている
```
Class String        // <~> は使えない
Class ArrayList<E>  // <~>を付けて使う
Class HashMap<K, V> // <~, ~>を付けて使う
```

### 自作クラスでの仮型引数の利用 E
- **Eは借方引数(formal type parameter)**と呼ばれ、クラスないのフィールドやメソッドの定義に広く使用できる
- **Eを使って定義されたクラスは、それ自体ではまだ未完成。Eの部分が実際にどのような型になるかは、この時点では確定していない**
- 実際にクラスを利用する際に、**実型引数(actual type parameter)** を指定して決定する
  - e.g. `Pocket<String> s`　コンパイラは裏で、`Pocket<String>`クラスを生成する
```
public class Pocket<E>{
    private Object E data;
    public void put (E d) {this.date = d;}
    public E get() {return this.date;}
  }
```

### 利用できる実型引数の制限
- 単に`E`だけで宣言されているクラスは、あらゆる実型引数を指定できる
- 制限したい場合には、下のように宣言をする
`public class Pocket<E extends Character>`
- すると、Characterクラスの子クラスのみが、実型引数として利用できる

### 列挙型
- 指定した種類の値だけを入れることのできる列挙型
- その型の変数に入りうる値を、**列挙子(enum constants)**　としてカンマで区切って宣言する

```
アクセス修飾子 enum 列挙型名 {
  列挙子 1, 列挙子 2, 列挙子 3 --- 列挙子 X;
}
```

```
enum AccountType{
  FUTUU, TOUZA, TEIKI;
}
```

#### static import 宣言
- `AccontType.FUTUT`と書くのが面倒ならば、ソースコードの銭湯で、 **static import** 宣言を行うことで、省略した指定が可能になる

- static import昨日は、列挙子以外にもstaticがついたクラスメンバにつて記述の省略を可能にんする
- ソースコードの先頭で`import static java.lang.System`と阮元をすることで、次のようなコードの記述も可能に

```
out.println("System部分は省略できます");
```

### インナークラス
- Javaでは **クラス宣言プロックの中に、さらにクラス宣言を書くことが許されている** 
- 内側に宣言されたクラスのことを、**インナークラス** または内部クラスという
- 3種類のインナークラスがある
  - メンバクラス
    - 他のクラスのメンバとして定義するクラス
    - 宣言場所 クラスブロックの中、フィールドやメソッドの隣
  - ローカルクラス
    - 宣言場所　クラスブロックの中、他の分の隣
  - 匿名クラス
    - 宣言場所　文の中（式の一部）（親クラスを指定）
- インナークラスに共通する特徴
  - 他のクラスの内部で宣言されること
  - 外側クラスのメンバや変数に対して特別にアクセスできることj
```
# メンバクラス
class Outer{
  void add(){}
  class Inner{}
}
# ローカルクラス
class Outer{
  void add(){
    int a = 10;
    class Inner{}
  }
}

# 匿名クラス
class Outer {
  void add(){
    int a = 10;
    Object o = new Object(){}
  }
}
```

#### メンバクラス member class
- 他のクラスのメンバとして定義するクラス
- メンバの種類に、フィールド、メソッドに加えて、クラスが加わった
- 特徴
  - 他のクラスの宣言ブロックの中で、メンバとして宣言する
  - `protected`や`private`などのアクセス修飾も利用可能
  - `static`が**あるかないかで全く別物**
    - staticつきのものは言語仕様上、インナークラスの範囲には含まれないことになっている
    

# 6 ラムダ式とオブジェクト
- 第一級オブジェクト
  - あるプログラミング言語において、プログラムの実行中に生み出したり、変数に代入したりできるもののこと
    - 例えば、データ（数値や文字）、データ構造（配列や構造体）、インスタンス
  - 第一級オブジェクトとしてどのようなものが扱えるかは、プログラミング言語の特徴を示す
    - 例えば、C言語はインスタンスを第一級オブジェクトとして扱えないから、オブジェクト指向プログラミングを実践することが困難
  - **Java8からは、第一級オブジェクトとして関数（function）が加わる**
    cf. 関数とは input があり、Processがあり、Outputがあるもの。世の中関数だらけ
#### Javaにおける関数
- 何らかの情報(Input)を引数として受け取り、
- 何らかの処理(Process)を行い
- 何らかの結果(Output)を戻り値として返す、ひとまとまりの処理ロジック
### メソッドと関数の違い
1. メソッドは、クラスに属する一種の関数
   1. 関数はIPO構造を伴う処理ロジック、ぐらいの意味
   2. 一方メソッドといううことbは、オブジェクト指向のための用語として登場した。外部からの呼び出しに応えて動作するために、あるクラスのメンバとして記述されたIPO構造を伴う処理ロジック、通常、クラスに属さないものはメソッドとは呼ばない
   3. **メソッド is a 関数** の関係
2. 関数にとって名前は重要ではなく、必須ではない
   1. Javaのメソッドは名前をもつ。名前がなければ呼び出すことはできない。
   2. 関数にとっては名前は重要ではない。IPO構造があれば良い。実際名前を持たない関数もある

### 関数オブジェクト
- Java8以降、関数を第一級オブジェクトとして利用できるようになった
- プログラム内で変数に関数を代入できるようになった

```

public class Function {
  public static void main(String[] args) {
    // sub メソッドの処理ロジックを変数funcに代入する
    IntBinaryOperator func = Function::sub;
    // 変数funcに格納されている処理ロジックを、引数と合わせて実行する
    int a = func.applyAsInt(5, 3);
    System.out.println("5-3は" + a);
  }
  public static int sub(int a, int b){
    return a - b;
  }

}
```

### 変数へのメソッド参照の格納
- **代入されているのはメソッドへの参照**
- JVMのメモリ空間の中に、sub()メソッドの実態があり、そのメモリ番地をさす情報が入っているとイメージする
  - このイメージすると、変数にインスタンスの参照が代入されたのと同じこと

```
変数名 = クラス名::そのクラスの静的メソッド
変数名 = インスタンス変数名::そのインスタンスのメソッド名
```

###　関数オブジェクトを格納可能な型
- ある特定の引数と戻り値をもつ関数オブジェクトを格納できるのは、その引数と戻り値をもつメソッド宣言を含んだSAMインターフェースの型
- Single-abstract-method interface
  - 抽象メソッドを一つしか含まないインターフェースのこと
  - インターフェース名は何でも酔いが、格納したい関数オブジェクトと同じ日キスや戻り値を持ったメソッドを一つだけ含んだインターフェースを宣言し、その型を使わなければならない
  - なので、自分で実装する時には、以下のようになる
```
public interface MyFunction {
  public abstract int call(int x, int y);
}

public class Main{
  public static int sub(int a, int b){
    return a - b;
  }

  public static void main(String[] args) {
    // 宣言したインターフェースの型に代入
    MyFunction func = Main::sub;
    //　インターフェースのメソッドで呼び出し
    int a = func.call(5, 3);
    System.out.println("5-3=" + a);
  }
}
```

- 関数オブジェクトを変数に格納したいと思うたびに開発者がインターフェースをいちいち宣言しなくて良いように、`java.util.function`パッケージのAPIとして、いくつかのSAMインターフェースが用意されている

### ラムダ式
- メソッドとして定義した処理ロジック（関数）の実体は、プログラムの動作時に自動的に生成される（いつ利用されるかに関わらず）
- 一方で **必要な時に生成して作成することもできる**
- いかがラムダ式の書き方
```
(int 1, int b) -> { return a - b;};
( 型 引数名1, 型 引数名2, ...) -> {
  処理1;
  処理2;
  ...
  return 戻り値;
}
```

```
// インスタンスを受け取り、そのフィールドの値を返却
(Hero h) -> {return h.getHp();};
// 何も引数としhて受け取らず、現在日時を返却j
() -> {return new java.util.Date()}
// 配列を受け取り、そのコピーを返す
(long[] array ) -> {
  long[] array2 = java.util.Arrays.copyOf(array, array.length):
  java.util.Arrays.sort(array2);
  return array2;
}
// 関数オブジェクトを受け取り、2回呼び出した合計を返却する
(IntBinaryOperator func, int a, int b) -> {
  int result = func.applyAsInt(a, b) +  func.applyAsInt(a, b);
  return result;
}
```
## ラムダ式の応用
- ラムダ式は、関数の実態が生み出される際に、その時点でアクセス可能な全ての変数の情報を記憶しラムダ式内で利用できる特徴がある。
- つまりラムダ式の外にある変数を利用できる。ただしラムダ式の外にある変数の変更はできない
- 関数オブジェクトやラムダ式は、他の機能と組み合わせることで効果が発揮される。
- 下のような処理が1行でかける
```
for (Integer i : list1){
  i = i * 2;
}

// ラムダ式
list1.stream().forEach(i -> i * 2)
```
- ArrayListやHashSetなど、`java.util.Collection`を実装している全てのクラスは、Java8から`stream`メソッドを持つようになった
- Streamは一括処理などができる。Streamインスタンスが持つ代表的なメソッドが`forEach()`
- 古いJavaでは使えないが、Streamを用いることで膨大なメリットがある。`従来よりも処理を高速化できる`
- 下の処理の梅には、並列理処理を行うことで、近年のマルチコアCPUを利用できる
```
list1.paralellStream().forEach( i -> i * 2);

```

# 07JVM
- JavaのAPIにはJVMに対して直接操作を行えるものがある。
- `System.exit()`
  - その場でプログラムが終了する
- `java.lang.ProcessBuilder`
  - Javaプログラムから他のプログラムを起動できる。計算結果のをファイルに出力して甘露したらメモ帳を起動するなどの動作がおこなえる
## システムプロパティの利用
- `Map<String, String>`
  - JVMの動作に関する様々な情報を、格納利用している。
  - JVM生成時に（Javaプログラム起動直後）に様々な値が二度王的に設定される
  - またシステムプロパティにあたいも設定できる
  - **どのようなクラスからも直接読み書きできるが、不具合の原因にもなりやすい**
- `java.lang.Runtime.getRuntime()`
  - JVMのメモリ状態を取得できる
- リフレクション
  - 実行時にクラスの情報を取得できるAPI

# Chapter 09 ファイルの操作

## Javaにおけるファイルの操作手順

- 必ず以下の手順で行う
1. 最初に一回ファイルを開く
2. 必要な回数ファイルのデータを書き込む・読み込む
3. 最後に一回ファイルを閉じる

- ファイルのアクセス方法
    - ランダムアクセス
        - 読み書きしたい場所とデータをその都度指定する
        - 速度や扱えるデータの量に制約がある
    - シーケンシャルアクセス
        - 先頭から順番に読み込む
        - こちらがファイル操作の基本的なアクセス方法
        - シーケンシャルアクセスが用いられる理由
            - JVMが管理しているデータ格納領域はメモリだけ
            - JVM以外の世界では、容量が大きいファイルがたくさん存在する（わかりやすいもので言えば動画とか）すなわち容量がわからないファイルだらけ → なので、JVMの外部にあるデータは、少しずつ読み込むのが基本的なアプローチとなる
            - それらを一気に読み込むと、`OutOfMemory` が発生する。
            - 

    // ファイルをインスタンス化することで開く
    FileWriter fw = new FileWriter("filePath", true);
    fw.write("xxxx");
    // flushメソッドを必ず呼び出す。writeだけでは書き込まれないことが
    fw.flush();
    fw.close();

- ファイルの閉じ忘れには注意する
- `flush()`  で例外が発生すると後の`close()` が実行されない→ファイルが開いたままになる。なので、`finally` を指定するなどして、実行を保証する

※こちらのファイルの読み込みメソッドは新しいのか？確認する

    public class Main {
      public static void main(String[] args) throws IOException {
        FileReader fw = new FileReader("fileName");
    		int i = fw.read();
    		// これ以上読み込めるデータがない場合には、-1を返す
    		while(i !- -1) {
    			char c = (char) i;
    			System.out.println(c);
    			i = fw.read();
    		}
      }

### バイナリファイル

- テキストファイル
    - 文字として解釈可能なデータ、Javaのソースファイル、HTMLファイルなど
    - アクセス用API
        - `FIleWriter/FileReader`
- バイナリファイル
    - 文字として解釈できないデータ（バイト列）
    - Excelで作成したファイル、Javaのファイル、画像ファイル、動画ファイル
    - アクセス用API
        - `FileInputStream / FileOutputStream`

### 文字とバイトの関係

- 突き詰めれば、文字も全て0-1のデータ。だがどのようなバイトになるのかは、文字コードによって異なる
- Fileへの書き込みを行う際には、文字コードの指定が可能

## データの流れをストリームとして捉えると

- 文字列の読み込みもストリームとして捉える。そのように抽象的に捉えるとファイルの読み書き以外にも、データの流れをストリームとして考えられる

### 標準出力標準エラー出力標準入力

- 標準出力
    - ディスプレイ
    - 通常の画面表示に用いる
- 標準エラー出力
    - ディスプレち
    - エラー情報の画面表示
- 標準入力
    - キーボード
    - キーボードからの入力

## フィルタの活用

- Streamの途中にも様々な変換処理を入れることができる。それをフィルタと呼ぶ
- フィルタの特徴
    - Filter ~ クラスを継承している
    - 単独で存在できず、他に接続する形で生成する

        FileOutputStream fos = new FileOutputStream("data.txt");
        CipherOutputStream = cos new CipherOutputStream(fos, algo);
        cos.write(65);

    - フィルタを複数連結することができる

### バッファリングフィルタ

- 文字情報用
    - `BufferedReader, BufferedWriter`
- バイト情報用
    - `BufferedInputStream, BufferedOutputStream`
- いずれもデータの変換は行わない
- データを溜め込み、まとまった量になったところで一気に処理を行う
- データを貯めて、一定量処理するメリット
    - 処理性能の向上
        - 少量のデータを何度も書き込む要求よし長谷兄、データをひとまとまりにして1回の書き込み要求をする方が、早く処理が終了する
    - まとまった単位でデータを読める。
        - 例えば、開業までの1行を読み込むなど
- ファイルを操作する際には、バッファリングフィルタを利用する。利用しないことはほとんどない

# chapter10 様々なファイル形式

- データフォーマット
    - 複数のデータをドンような形式順序で保存するかを定めたルールのこと
    - 複数のデータをファイルに保存したり、ネットワークを経由して遠隔地に伝送したりする場合に重要な役割を果たす。
    - ファイルフォーマット
        - ファイル内のデータ構造を規定するもの
    - メッセージフォーマットまたは電文フォーマット
        - ネットワーク経由で伝送されるひとかたまりのメッセージのデータ構造を規定するものは

## 汎用データフォーマット

- どのようなフォーマットを使うかは開発者の自由
- ただし、世の中には有名な汎用データフォーマットが存在する

### CSV Comma-Separated Values

- 複数のデータをカンマで区切って順に格納するフォーマット
- CSV内でデータを区切るために使われる文字はデリミタと呼ばれる（通常はカンマが利用される）
- 厳密な操作を利用するにはCSV処理専用の機能を持つライブラリを利用した方が良い。

### プロパティファイル

- CSV形式のカンマ区切りやスペース区切りでは力武装な場合は、Javaではプロパティファイル形式を利用することがある。
- プログラムの設定ファイルとしてよく利用されている
- データをキーと値のペアで格納する
- プロパティファイルの主なルール
    - データは文字情報として保存する
    - 各行には、キーと値をペアとして、それらを「ペアデリミタ」で区切り記述する
    - ペアデリミタ
        - = , :
    - コメントアウト
        - #, !
    - ファイルの拡張子には、`.properties`
- プロパティファイルを読み込み
    - Propertiesクラスを利用する
        - Propertiseクラスは全てのデータを文字列として扱う、整数やboolean型の値を取り扱う場合には、明示的に型を変換する

    public class Main {
    	public static void main(String[] args) {
    		Reader fr = new FileReader("filepath.properties");
    		Propertis p = new Properties;
    		p.load(fr); // ファイルの内容を読み込む
    		String name = p.getProperty("hostName");
    		String adress = p.getProperty("hostAdress");
    		...
    	}
    }

## オブジェクトの直列化

- 各データがどのような形式で保存されているのか気にしない。とにかく丸ごと保存するメソッド
- 複雑なデータ構造を持っているデータを0と1の単純な羅列に「並ばせること」ができる
- **直列化**
    - あるインスタンスの内容（全フィールド）を一つの命令で丸ごとそのままバイト列に変換する
    - その逆に、バイト列をインスタンスに戻したりする操作のこと
- シリアライズ
    - インスタンス → バイト列
- デシリアライズ
    - バイト列 → インスタンス
- 直列化の準備
    - 直列化されるクラスは、`java.io.Serializable`  を実装しなければならない

    public class Hero implements Serializable {
    	private String name;
    	private int age;
    	private int height;
    
    ...
    }

java.io.ObjectOutputStreamやjava.io.ObjectInputStreamを利用することで、インスタンス自体をストリーム経由で保存、復元できるようになる

    // 1. インスタンスの直列化と保存
    Hero hero1 = new Hero("Alex", 25, 180);
    FileOutputStream fos = new FileOutputStream("filename.dat");
    ObjectOutputStream oos = new ObjectOutputStream(fos);
    oos.writeObject(hero1); // インスタンス -> バイト列へ変換
    oos.flush();
    oos.close();
    
    // 2. ファイルからインスタンスを復元
    FileInputStream fis = new FileInputStream("filename.dat");
    ObjectInputStream ois = new ObjectInputSteram(fis);
    Hero hero2  = (Hero) ois.readObject(); // バイト -> インスタンス
    ois.close();
    
    

直列化の注意点例外

1. Serializableを実装していないクラス型のフィールドは直列化の対象にならない
2. staticがついたフィールドは直列化の対象にならない
3. transientキーワードで修飾したフィールドは直列化の対象にならない

### シリアルバージョンUID

- 直列化は便利だが、直列化してファイルに保存した後に、クラス自体が変更されたとする（フィールドの追加削除など）
- この状態で改良前に直列化で保存したファイルから、インスタンスを復元しようとすると、矛盾した状態で復元されてしまう
- こうした事故を防ぐために、シリアルバージョンUIDをクラスフィールドとして宣言しておく

    public class Hero implements Serializable {
    	private static final long serialVersionUID = 812928373954L;
    }

#  11 ネットワーク通信

## 高水準命令と低水準命令

- Javaではネットワークつ芯を簡単に実現するためのクラスが`java.net` パッケージで提供されている。
- 大きく分けて二つのグループがある
- 高水準API
    - 簡単に利用できるが細かいことはできない
    - クラス
        - URL
- 低水準API
    - 細かいことができるが、複雑で手間がかかる
    - IPアドレス、ポート、暗号化つす芯などの制御が可能
    - クラス
        - InetAdress, Proxy, Socket
- `[java.net](http://java.net)` クラスを利用することで、Webページの取得が可能
- `inputstream`のさあ気は、自分のPCにあるファイルではんくインターネット上のwebページ
- ファイルと1バイトずつ読むのは同じ処理
## ソケットクラスの利用
- `ServerSocket`を使ってサーバを作る

# 12データベースアクセス
- JavaプログラムからRDBに対してデータの書き込みを行うと気には、`SQL`を用いる
- ファイルの時のようなストリームは利用しない

## データベース利用のためのAPI
- DirectManager
    - DBMSへの接続準備のためにひとつながり利用する
- Connection
    - DBMSへの接続や切断のために利用する
- PreparedStatement
    - SQL文を送信するために利用する
- ResultSet
    - DBMSかあr検索結果を受け取る際に利用する
```$xslt
<javaプログラム> ---- <JDBC API> ---- <Oracleドライバ(JAR), PostgreSQLドライバ(JAR) ...> --- <各種DMBS>
```
- 各DBMS用のドライバを準備する。JavaプログラムでJDBCAPIを利用すれば、その裏方としてJDBCドライバが動き、ねっっトォアーク接続やSQL.のやりとりをこおなってくれる
- トランザクション
- 送信する一つ以上のSQLの要求を一つのグループとしてええええ扱う考え方
  - コミット
    = 全てが成功して初めて、処理結果を確定する **コミット** 
    - 途中で失敗したら、トランザクション実行前の状態に戻す（トールバック）
## `connection`オブジェクトの利用
- JDBCを用いてのトランザクションの制御のために利用するう
-


理解が簡単なデザインパターンから
- Facade
  - 内部を隠す
- Singleton
  - 唯一無二
  - インスタンスの生成を許さないクラス
  - ネットワーク接続を管理するクラスなどの場合